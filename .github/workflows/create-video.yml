name: ðŸŽ¬ Create Video (Optimized)

on:
  repository_dispatch:
    types: [create_video]

jobs:
  create-video:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    container:
      image: docker.io/cashewin/video-tools:latest
      credentials:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
      options: --user 0

    defaults:
      run:
        shell: bash

    steps:
      - name: ðŸ§¾ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“¦ Prepare assets from payload (PARALLEL DOWNLOADS)
        timeout-minutes: 3
        run: |
          set -euo pipefail
          mkdir -p assets output /tmp

          echo "================================================"
          echo "ðŸŽ¬ VIDEO CREATION STARTING (9:16 Vertical) - OPTIMIZED"
          echo "================================================"

          echo '${{ toJson(github.event.client_payload.images) }}' > /tmp/images.json

          # Parallel image downloads using background processes
          idx=0
          pids=()
          while IFS= read -r image_url; do
            if [ -n "$image_url" ] && [ "$image_url" != "null" ]; then
              outfile="assets/image_$(printf '%03d' "$idx").png"
              echo "ðŸ“¥ Starting download $((idx + 1)): $image_url"
              (curl -L --fail --retry 2 --max-time 30 --connect-timeout 10 -o "$outfile" "$image_url" && echo "âœ… Downloaded image $((idx + 1))") &
              pids+=($!)
              idx=$((idx + 1))
            fi
          done < <(jq -r '.[]?' /tmp/images.json)

          # Download voiceover in parallel
          if [ -n "${{ github.event.client_payload.voiceover_url || '' }}" ]; then
            echo "ðŸŽ¤ Starting voiceover download..."
            (curl -L --fail --retry 2 --max-time 30 --connect-timeout 10 --retry-delay 1 -o assets/voiceover_raw "${{ github.event.client_payload.voiceover_url }}" && echo "âœ… Voiceover downloaded") &
            pids+=($!)
          fi

          # Download background music in parallel
          if [ -n "${{ github.event.client_payload.background_music_url || '' }}" ]; then
            echo "ðŸŽµ Starting background music download..."
            (curl -L --fail --retry 2 --max-time 30 --connect-timeout 10 --retry-delay 1 -o assets/bgmusic.mp3 "${{ github.event.client_payload.background_music_url }}" && echo "âœ… Background music downloaded") &
            pids+=($!)
          fi

          # Wait for all parallel downloads to complete
          echo "â³ Waiting for all downloads to complete..."
          for pid in "${pids[@]}"; do
            wait $pid || echo "âš ï¸ Download process $pid failed"
          done

          echo "ðŸ“Š Total images: $idx"
          ls -lh assets/

          # Process voiceover if exists
          if [ -f assets/voiceover_raw ]; then
            if ffprobe -v error -select_streams a -show_entries stream=codec_name -of csv=p=0 assets/voiceover_raw >/dev/null 2>&1; then
              mv assets/voiceover_raw assets/voiceover.mp3
              echo "âœ… Audio file ready (already encoded)"
            else
              echo "ðŸ”„ Converting PCM to MP3..."
              ffmpeg -y -f s16le -ar 24000 -ac 1 -i assets/voiceover_raw \
                -c:a libmp3lame -b:a 128k -ar 48000 \
                assets/voiceover.mp3
              rm assets/voiceover_raw
              echo "âœ… PCM to MP3 conversion complete"
            fi
            
            # Validate voiceover file is not corrupted
            VO_DUR=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3 2>/dev/null || echo "0")
            echo "â„¹ï¸ Voiceover file duration: ${VO_DUR}s"
          fi

      - name: ðŸ“ Save subtitle text
        if: github.event.client_payload.subtitle_text != '' && github.event.client_payload.subtitle_text != null
        run: |
          cat > /tmp/subtitle_text.txt <<'EOF'
          ${{ github.event.client_payload.subtitle_text }}
          EOF

      - name: ðŸŽžï¸ Create vertical video (9:16) - SINGLE-PASS OPTIMIZED
        timeout-minutes: 8
        run: |
          set -euo pipefail
          
          echo "================================================"
          echo "ðŸŽ¥ VIDEO CREATION - OPTIMIZED SINGLE-PASS"
          echo "================================================"
          
          # âš¡ CRITICAL: Use duration from app payload (user's selection)
          PAYLOAD_DURATION="${{ github.event.client_payload.duration || '' }}"
          
          if [ -n "$PAYLOAD_DURATION" ] && [[ "$PAYLOAD_DURATION" =~ ^[0-9]+$ ]]; then
            # User specified duration in app - USE THIS
            DURATION=$PAYLOAD_DURATION
            echo "âœ… Using duration from app: ${DURATION}s"
          elif [ -f assets/voiceover.mp3 ]; then
            # No duration specified, detect from voiceover
            RAW_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3 2>/dev/null || echo "30")
            DURATION_INT=$(printf "%.0f" "$RAW_DURATION" 2>/dev/null || echo "30")
            
            # Validate voiceover duration is reasonable (detect corruption)
            if [[ "$DURATION_INT" =~ ^[0-9]+$ ]] && [ "$DURATION_INT" -ge 1 ] && [ "$DURATION_INT" -le 600 ]; then
              DURATION=$DURATION_INT
              echo "ðŸŽ¤ Detected voiceover duration: ${DURATION}s"
            else
              echo "âš ï¸ Invalid voiceover duration detected (${DURATION_INT}s) - file may be corrupted. Using fallback: 30s"
              DURATION=30
            fi
          else
            # No duration and no voiceover - use default
            DURATION=30
            echo "â„¹ï¸ No duration specified, using default: ${DURATION}s"
          fi
          
          IMG_COUNT=$(ls -1 assets/image_*.png 2>/dev/null | wc -l)
          if [ "$IMG_COUNT" -eq 0 ]; then
            echo "âŒ No images found!"
            exit 1
          fi
          
          TRANSITION_DURATION=0.5
          DURATION_PER_IMAGE=$(echo "scale=2; ($DURATION + ($IMG_COUNT - 1) * $TRANSITION_DURATION) / $IMG_COUNT" | bc)
          
          echo "ðŸ“Š Images: $IMG_COUNT | Duration: ${DURATION}s | Per-image: ${DURATION_PER_IMAGE}s"

          # Build optimized filter - 24 FPS for speed
          FILTER_COMPLEX=""
          
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            FILTER_COMPLEX="${FILTER_COMPLEX}[${i}:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,setsar=1,fps=24,zoompan=z='min(zoom+0.002,1.05)':d=${DURATION_PER_IMAGE}*24:s=1080x1920:fps=24[v${i}];"
          done
          
          FILTER_COMPLEX="${FILTER_COMPLEX}[v0]"
          for i in $(seq 1 $((IMG_COUNT - 1))); do
            OFFSET=$(echo "scale=2; $i * ($DURATION_PER_IMAGE - $TRANSITION_DURATION)" | bc)
            FILTER_COMPLEX="${FILTER_COMPLEX}[v${i}]xfade=transition=fade:duration=${TRANSITION_DURATION}:offset=${OFFSET}"
            if [ $i -lt $((IMG_COUNT - 1)) ]; then
              FILTER_COMPLEX="${FILTER_COMPLEX}[vt${i}];[vt${i}]"
            fi
          done
          FILTER_COMPLEX="${FILTER_COMPLEX}[vout]"

          INPUTS=""
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            INPUTS="$INPUTS -i assets/image_$(printf '%03d' $i).png"
          done

          echo "ðŸŽ¬ Creating base video with ultrafast preset..."
          ffmpeg -y $INPUTS -filter_complex "$FILTER_COMPLEX" -map "[vout]" \
            -c:v libx264 -pix_fmt yuv420p -preset ultrafast -crf 25 \
            -movflags +faststart -t $DURATION \
            output/base.mp4

          echo "âœ… Base video created"

          # Prepare subtitle filter if needed
          SUBTITLE_FILTER=""
          if [ -f /tmp/subtitle_text.txt ]; then
            echo "ðŸ“ Generating subtitles..."
            SUBTITLE_TEXT=$(cat /tmp/subtitle_text.txt)
            WORD_COUNT=$(echo "$SUBTITLE_TEXT" | wc -w)
            
            if [ "$WORD_COUNT" -gt 0 ]; then
              SECONDS_PER_WORD=$(echo "scale=4; $DURATION / $WORD_COUNT" | bc)
              
              > output/subs.srt
              WORDS=($SUBTITLE_TEXT)
              SUBTITLE_NUM=1
              CURRENT_TIME=0
              WORDS_PER_SUBTITLE=5
              
              for ((i=0; i<${#WORDS[@]}; i+=WORDS_PER_SUBTITLE)); do
                CHUNK="${WORDS[@]:i:WORDS_PER_SUBTITLE}"
                CHUNK_WORD_COUNT=$(echo "$CHUNK" | wc -w)
                START_TIME=$CURRENT_TIME
                CHUNK_DURATION=$(echo "scale=4; $CHUNK_WORD_COUNT * $SECONDS_PER_WORD" | bc)
                END_TIME=$(echo "scale=4; $START_TIME + $CHUNK_DURATION" | bc)
                
                format_time() {
                  local seconds=$1
                  local h=$(echo "$seconds / 3600" | bc)
                  local m=$(echo "($seconds % 3600) / 60" | bc)
                  local s=$(echo "$seconds % 60" | bc)
                  local int_s=${s%.*}
                  local ms=$(echo "($s - $int_s) * 1000" | bc)
                  printf "%02d:%02d:%02d,%03d" ${h:-0} ${m:-0} ${int_s:-0} ${ms%.*}
                }
                
                echo "$SUBTITLE_NUM" >> output/subs.srt
                echo "$(format_time $START_TIME) --> $(format_time $END_TIME)" >> output/subs.srt
                echo "$CHUNK" >> output/subs.srt
                echo "" >> output/subs.srt
                
                SUBTITLE_NUM=$((SUBTITLE_NUM + 1))
                CURRENT_TIME=$END_TIME
              done
              
              SUBTITLE_FILTER=",subtitles=output/subs.srt:force_style='FontName=Noto Sans,Bold=1,FontSize=12,PrimaryColour=&HFFFFFF&,OutlineColour=&H000000&,BackColour=&H80000000&,BorderStyle=4,Outline=2,Shadow=0,MarginV=45,Alignment=2'"
              echo "âœ… Subtitles prepared"
            fi
          fi

          # Build single-pass complex filter for video + audio
          OUTPUT_NAME="${{ github.event.client_payload.output_name || 'output.mp4' }}"
          
          # Determine audio inputs and filters
          AUDIO_INPUTS=""
          HAS_VOICEOVER=false
          HAS_BGMUSIC=false
          
          if [ -f assets/voiceover.mp3 ]; then
            AUDIO_INPUTS="$AUDIO_INPUTS -i assets/voiceover.mp3"
            HAS_VOICEOVER=true
          fi
          
          if [ -f assets/bgmusic.mp3 ]; then
            AUDIO_INPUTS="$AUDIO_INPUTS -i assets/bgmusic.mp3"
            HAS_BGMUSIC=true
          fi

          # SINGLE-PASS: Combine video processing + subtitle + audio mixing
          if [ "$HAS_VOICEOVER" = true ] && [ "$HAS_BGMUSIC" = true ]; then
            echo "ðŸŽµ Single-pass: Video + Subtitles + Voiceover + Background Music"
            
            VO_IDX=1
            BG_IDX=2
            
            ffmpeg -y -i output/base.mp4 $AUDIO_INPUTS \
              -filter_complex "[0:v]null${SUBTITLE_FILTER}[vout];[${BG_IDX}:a]volume=0.2,aloop=loop=-1:size=2e9[bg];[${VO_IDX}:a][bg]amix=inputs=2:duration=first:dropout_transition=2[aout]" \
              -map "[vout]" -map "[aout]" \
              -c:v libx264 -preset ultrafast -crf 25 \
              -c:a aac -b:a 128k \
              -movflags +faststart \
              -t $DURATION \
              "output/$OUTPUT_NAME"
              
          elif [ "$HAS_VOICEOVER" = true ]; then
            echo "ðŸŽ¤ Single-pass: Video + Subtitles + Voiceover"
            
            ffmpeg -y -i output/base.mp4 -i assets/voiceover.mp3 \
              -filter_complex "[0:v]null${SUBTITLE_FILTER}[vout]" \
              -map "[vout]" -map 1:a \
              -c:v libx264 -preset ultrafast -crf 25 \
              -c:a aac -b:a 128k \
              -movflags +faststart \
              -t $DURATION \
              "output/$OUTPUT_NAME"
              
          elif [ "$HAS_BGMUSIC" = true ]; then
            echo "ðŸŽµ Single-pass: Video + Subtitles + Background Music"
            
            ffmpeg -y -i output/base.mp4 -i assets/bgmusic.mp3 \
              -filter_complex "[0:v]null${SUBTITLE_FILTER}[vout];[1:a]volume=0.4,aloop=loop=-1:size=2e9[aout]" \
              -map "[vout]" -map "[aout]" \
              -c:v libx264 -preset ultrafast -crf 25 \
              -c:a aac -b:a 128k \
              -movflags +faststart \
              -t $DURATION \
              "output/$OUTPUT_NAME"
              
          else
            echo "ðŸŽ¬ Single-pass: Video + Subtitles"
            
            if [ -n "$SUBTITLE_FILTER" ]; then
              ffmpeg -y -i output/base.mp4 \
                -vf "null${SUBTITLE_FILTER}" \
                -c:v libx264 -preset ultrafast -crf 25 \
                -movflags +faststart \
                -t $DURATION \
                "output/$OUTPUT_NAME"
            else
              mv output/base.mp4 "output/$OUTPUT_NAME"
            fi
          fi

          # Cleanup temp files immediately
          rm -f output/base.mp4 output/subs.srt

          echo "================================================"
          echo "âœ… VIDEO CREATED SUCCESSFULLY (OPTIMIZED)!"
          echo "================================================"
          ls -lh "output/$OUTPUT_NAME"
          
          FINAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "output/$OUTPUT_NAME" 2>/dev/null || echo "unknown")
          if [[ "$FINAL_DURATION" =~ ^[0-9]+\.?[0-9]*$ ]]; then
            echo "â±ï¸  Duration: $(printf "%.1f" "$FINAL_DURATION")s"
          fi
          echo "ðŸ“ Resolution: 1080x1920 (9:16)"
          echo "ðŸ“¦ Size: $(ls -lh "output/$OUTPUT_NAME" | awk '{print $5}')"

      - name: ðŸŽ¨ Apply watermark (if enabled)
        if: github.event.client_payload.watermark_enabled == 'true' || github.event.client_payload.watermark_enabled == true
        timeout-minutes: 2
        run: |
          set -euo pipefail
          
          echo "ðŸŽ¨ Applying watermark..."
          
          OUTPUT_NAME="${{ github.event.client_payload.output_name || 'output.mp4' }}"
          INPUT_VIDEO="output/$OUTPUT_NAME"
          WATERMARKED_VIDEO="output/${OUTPUT_NAME%.mp4}_watermarked.mp4"
          
          WATERMARK_TYPE="${{ github.event.client_payload.watermark_type || 'text' }}"
          WATERMARK_POSITION="${{ github.event.client_payload.watermark_position || 'bottom-right' }}"
          WATERMARK_OPACITY="${{ github.event.client_payload.watermark_opacity || '70' }}"
          
          if [ "$WATERMARK_TYPE" = "text" ]; then
            WATERMARK_TEXT="${{ github.event.client_payload.watermark_text || 'YourBrand' }}"
            WATERMARK_FONTSIZE="${{ github.event.client_payload.watermark_fontsize || '48' }}"
            WATERMARK_COLOR="${{ github.event.client_payload.watermark_color || '#FFFFFF' }}"
            
            FFMPEG_COLOR="0x${WATERMARK_COLOR#\#}"
            OPACITY=$(echo "scale=2; $WATERMARK_OPACITY / 100" | bc)
            
            case "$WATERMARK_POSITION" in
              "top-left") X_POS="20"; Y_POS="20" ;;
              "top-right") X_POS="(w-text_w-20)"; Y_POS="20" ;;
              "bottom-left") X_POS="20"; Y_POS="(h-text_h-20)" ;;
              "bottom-right") X_POS="(w-text_w-20)"; Y_POS="(h-text_h-20)" ;;
              "center") X_POS="(w-text_w)/2"; Y_POS="(h-text_h)/2" ;;
              *) X_POS="(w-text_w-20)"; Y_POS="(h-text_h-20)" ;;
            esac
            
            ESCAPED_TEXT=$(echo "$WATERMARK_TEXT" | sed "s/'/\\\\'/g" | sed "s/:/\\\\:/g")
            
            ffmpeg -y -i "$INPUT_VIDEO" \
              -vf "drawtext=text='${ESCAPED_TEXT}':fontsize=${WATERMARK_FONTSIZE}:fontcolor=${FFMPEG_COLOR}@${OPACITY}:x=${X_POS}:y=${Y_POS}" \
              -c:a copy -preset ultrafast \
              -movflags +faststart \
              "$WATERMARKED_VIDEO"
              
          elif [ "$WATERMARK_TYPE" = "image" ]; then
            WATERMARK_URL="${{ github.event.client_payload.watermark_image_url }}"
            WATERMARK_SCALE="${{ github.event.client_payload.watermark_scale || '20' }}"
            
            if [ -z "$WATERMARK_URL" ]; then
              echo "âŒ Image watermark URL not provided"
              exit 1
            fi
            
            curl -L --fail --retry 2 --max-time 30 -o assets/watermark.png "$WATERMARK_URL"
            
            OPACITY=$(echo "scale=2; $WATERMARK_OPACITY / 100" | bc)
            SCALE_PERCENT=$(echo "scale=2; $WATERMARK_SCALE / 100" | bc)
            
            case "$WATERMARK_POSITION" in
              "top-left") OVERLAY_POS="20:20" ;;
              "top-right") OVERLAY_POS="W-w-20:20" ;;
              "bottom-left") OVERLAY_POS="20:H-h-20" ;;
              "bottom-right") OVERLAY_POS="W-w-20:H-h-20" ;;
              "center") OVERLAY_POS="(W-w)/2:(H-h)/2" ;;
              *) OVERLAY_POS="W-w-20:H-h-20" ;;
            esac
            
            ffmpeg -y -i "$INPUT_VIDEO" -i assets/watermark.png \
              -filter_complex "[1:v]scale=iw*${SCALE_PERCENT}:ih*${SCALE_PERCENT},format=rgba,colorchannelmixer=aa=${OPACITY}[wm];[0:v][wm]overlay=${OVERLAY_POS}" \
              -c:a copy -preset ultrafast \
              -movflags +faststart \
              "$WATERMARKED_VIDEO"
          fi
          
          mv "$WATERMARKED_VIDEO" "$INPUT_VIDEO"
          echo "âœ… Watermark applied"

      - name: ðŸ“¤ Upload video to backend
        timeout-minutes: 3
        run: |
          set -euo pipefail
          
          OUTPUT_NAME="${{ github.event.client_payload.output_name || 'output.mp4' }}"
          WEBHOOK_URL="${{ github.event.client_payload.callback_url }}"
          JOB_ID="${{ github.event.client_payload.job_id }}"
          WEBHOOK_SECRET="${{ github.event.client_payload.webhook_secret }}"
          
          if [ ! -f "output/$OUTPUT_NAME" ]; then
            echo "âŒ Video file not found: output/$OUTPUT_NAME"
            
            curl --max-time 30 -X POST "$WEBHOOK_URL" \
              -F "status=failed" \
              -F "job_id=$JOB_ID" \
              -F "webhook_secret=$WEBHOOK_SECRET" \
              -F "run_id=${{ github.run_id }}" \
              -F "error=Video file not found after processing"
            exit 1
          fi
          
          VIDEO_SIZE=$(stat -f%z "output/$OUTPUT_NAME" 2>/dev/null || stat -c%s "output/$OUTPUT_NAME")
          echo "ðŸ“¦ Video size: $((VIDEO_SIZE / 1024 / 1024)) MB"
          
          echo "ðŸ“¤ Uploading video to: $WEBHOOK_URL"
          
          HTTP_CODE=$(curl --max-time 180 -w "%{http_code}" -X POST "$WEBHOOK_URL" \
            -F "video=@output/$OUTPUT_NAME" \
            -F "status=success" \
            -F "job_id=$JOB_ID" \
            -F "webhook_secret=$WEBHOOK_SECRET" \
            -F "run_id=${{ github.run_id }}" \
            -o /tmp/upload_response.txt)
          
          echo "ðŸ“Š Upload response code: $HTTP_CODE"
          cat /tmp/upload_response.txt || true
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "âœ… Video uploaded successfully!"
          else
            echo "âŒ Upload failed with code: $HTTP_CODE"
            exit 1
          fi

      - name: ðŸ§¹ INSTANT CLEANUP - Delete ALL resources
        if: always()
        run: |
          set +e
          
          echo "================================================"
          echo "ðŸ§¹ INSTANT CLEANUP STARTING"
          echo "================================================"
          
          # Delete generated video FIRST
          echo "ðŸ—‘ï¸ Deleting generated video..."
          rm -rf output/*.mp4 output/*.srt output/ 2>/dev/null || true
          echo "âœ… Video deleted"
          
          # Delete all downloaded assets
          echo "ðŸ—‘ï¸ Deleting downloaded assets..."
          rm -rf assets/*.png assets/*.mp3 assets/ 2>/dev/null || true
          echo "âœ… Assets deleted"
          
          # Delete temporary files
          echo "ðŸ—‘ï¸ Deleting temporary files..."
          rm -rf /tmp/*.txt /tmp/*.json /tmp/*.mp3 /tmp/*.png /tmp/*.mp4 2>/dev/null || true
          echo "âœ… Temp files deleted"
          
          # Clear any logs
          echo "ðŸ—‘ï¸ Clearing logs..."
          find . -type f -name "*.log" -delete 2>/dev/null || true
          echo "âœ… Logs cleared"
          
          echo "================================================"
          echo "âœ… CLEANUP COMPLETE - 0 ARTIFACTS REMAINING"
          echo "================================================"
          
          # Verify cleanup
          echo "ðŸ“Š Verification:"
          if [ ! -d "output" ]; then
            echo "âœ… output/ directory removed"
          fi
          if [ ! -d "assets" ]; then
            echo "âœ… assets/ directory removed"
          fi
          
          echo "ðŸŽ‰ Workflow complete - ALL resources deleted!"

      - name: âœ… Workflow completion marker
        if: always()
        run: |
          echo "================================================"
          echo "âœ… WORKFLOW FINISHED - NO LOOP POSSIBLE"
          echo "================================================"
          exit 0
